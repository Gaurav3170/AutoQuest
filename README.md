# AutoQuest
A Machine Learning Based Intelligent Question Paper Generator System Web Application for organizations ,colleges and schools to produce a PDF and Doc format supported document of the required subjects.
Welcome To AutoQuest:

How To Use :

	Step-1: Open www.autoquest.com
  
	Step-2: Click on Continue button.
  
	Step-3: You will enter into the welcome page of AutoQuest . Choose SignIn/SignUp as per your choice.
  
	Step-4: Enter your details and login into the web application Of AutoQuest.
  
	Step-5: Under Construction..
  
		Please wait for further updates on this project.

ABSTRACT  
An Intelligent Question Paper Generator System which generates Question Paper in Portable Document Format (PDF) and Docx Format. In this system we present a smart question paper generating system. In our system we allow administrator to input a set of questions and respective answers for option ticking. We also allow admin to provide weight age and complexity for each of these questions. After this the questions are stored in database along with their weight age. Now on question paper generating time the admin just has to select the percentage of difficulty. On this selection the system selects questions randomly in a way that their weight age makes up for 100 marks and according to difficulty that admin chooses the questions are chosen based on their complexity level. After this question paper is converted to pdf file and emailed to colleges on button click. 
 
 
 
 
 
 	 
 
 
 TABLE OF CONTENTS 
 
 
TITLE 	 	 	 	 	 	 	                                         Page No. 
 
Certificate	I 
Declaration	II 
Acknowledgement	III 
Abstract	IV 
List of Tables	VIII 
List of Figures	IX 

 
CHAPTER 1: INTRODUCTION…………………………………………………….…... 2-9 
1.1   Introduction of AutoQuest………………………………………………………….…… 2 
1.1.1   Objective of AutoQuest………………………………………………….….… 3 
1.1.2 Functionalities…………………………………………………………………... 3 
1.1.3 Scope………………………………………………………….……………….... 4   
1.1.4 Report of AutoQuest……………………………………….………….………... 4 
1.2 	MODULES OF AUTOQUEST…………………………………………………….… 5 
1.2.1 Input Data and Validation of Project…………….……………………….…... 5  
1.3  	SOFTWARE QUALITY PLAN……………………………………………………... 6 
 	1.3.1 Features of AutoQuest…………….………………………………………….… 6 	 
1.4 	SOFTWARE REQUIREMENT SPECIFICATION(SRS)………………………….... 7 
 	1.4.1 Identification of Needs……………….…………………………………………. 7 
1.5 Feasibility…………………………………….……………………………………...……. 8 
 	1.5.1 Economical Feasibility……………………….…………………………………. 8 
 	1.5.2 Technical Feasibility………………………………………….………………… 8 
 	1.5.3 Operational Feasibility………………………………………….………………. 9 	  
 
 
CHAPTER 2: ANALYSIS………………………………………………………………. 10-18 
2.1 SYSTEM DESIGN OF AUTOQUEST…………………………………………………… 10 
            2.1.1 User Interface Design………………………………………………………….… 11 
 	2.1.2 Preliminary Product Description………………………………………………… 11 
2.2 IMPLEMENTATION METHODOLOGY……………………………………………...… 13  
2.3 PROJECT PLANNING……………………………………………………………........... 14 
2.4 COST ESTIMATION ANALYSIS…………………………………………………….… 15  
2.5 TOOLS/PLATFORMS AND HARDWARE/SOFTWARE…………………………...… 16  
           REQUIREMENTS……………………………………………………………………. 16 
2.6 SYSTEM ANALYSIS……………………………………………………….………….... 17 
2.7 COMPARISON OF EXISTING VS PROPOSED SYSTEM……………………………. 18  
2.7.1 EXISTING SYSTEM…………………………………………………...……… 18 
2.7.2 PROPOSED SYSTEM…………………………………………………………. 18 
 
CHAPTER 3:DESIGN…………………………………………………………………... 19-30 
 	3.1 PROJECT PROFILE……………………………………………………………… 19 
 	3.2 USE CASE MODEL OF AUTOQUEST……………………………………….… 22  
 	3.3 DATAFLOW DIAGRAM……………………………………………………....… 22 
 	3.4 E-R DIAGRAM…………………………………………………………………… 24 
 	3.5 SCREENSHOTS OF DESIGN(FRONT-END) …………………...…………...… 26  
 
CHAPTER 4: CODING…………………………………………………………………. 31-48 
 
CHAPTER 5: TESTING……………………………………………………………….... 49-62 
 	5.1 SECURITY TESTING OF PROJECT……………………………………………. 49 
 	 	5.1.1 White Box Testing………………………………………………………. 49 
 	 	5.1.2 Black Box Testing………………………………………………………. 49 
 	 	5.1.3 Alpha Testing……………………………………………………………. 49 
 	 	5.1.4 Beta Testing…………………………………………………………...… 50 
 	 	5.1.5 Unit Testing……………………………………………………………... 50 
 	 	5.1.6 Integration Testing……………………………………………………… 50 
 	 	5.1.7 Validation Testing………………………………………………………. 50 
 	 	5.1.8 System Testing……………………………………………………….…. 50 
 	5.2 SOFTWARE SPECIFICATION TESTING…………………………………….... 51  	5.3 SCREENSHOTS OF SOFTWARE TESTING……………………………...…… 55 
CONCLUSION……………………………………………………………………………… 63 
FUTURE WORK……………………………………………………………………………. 64 
REFERENCES…………………………………………………………………………...… 65 
 	 
 
 
 
LIST OF TABLES 
 
 2.1 Table ………………………………………………………………………………….… 16 
 2.2 Table ……………………………………………………………………………………. 16 
 
 
 
 
 
 
 
 	  
LIST OF FIGURES 
2.1 Figure …………………………………………………………………………………… 13 
3.1 Figure …………………………………………………………………………………… 23 3.2 Figure …………………………………………………………………………………… 26 
3.3 Figure …………………………………………………………………………………… 26 
3.4 Figure …………………………………………………………………………………… 27 
3.5 Figure …………………………………………………………………………………… 27 
3.6 Figure …………………………………………………………………………………… 28 3.7 Figure …………………………………………………………………………………… 29 
3.8 Figure …………………………………………………………………………………… 30 
3.9 Figure …………………………………………………………………………………… 30 
4.1 Figure …………………………………………………………………………………… 31 
4.2 Figure …………………………………………………………………………………… 32 
4.3 Figure …………………………………………………………………………………… 32 4.4 Figure …………………………………………………………………………………… 33 4.5 Figure …………………………………………………………………………………… 33 
4.6.1 Figure ………………………………………………………………….……………… 33 4.6.2 Figure ……………………………………………………………….………………… 34 4.7.1 Figure …………………………………………………………….…………………… 34 4.7.2 Figure ………………………………………………………….……………………… 35 
4.8.1 Figure ……………………………………………………….………………………… 35 
4.8.2 Figure …………………………………………………….…………………………… 36 
4.9.1 Figure ………………………………….……….…….….…………….……………… 36 
4.9.2 Figure ………………………………………………….………………….…………… 37 
4.10 Figure …………………….….…….…….…….……….………….……...….………… 37 
4.11 Figure …………………………………………………………………………………… 38 4.12 Figure …………………………………………………………………………………… 39 4.13 Figure …………………………………………………………………………………… 39 4.14 Figure …………………………………………………………………………………… 40 4.15 Figure …………………………………………………………………………………… 40 4.16 Figure …………………………………………………………………………………… 41 4.17 Figure …………………………………………………………………………………… 41 
4.18 Figure …………………………………………………………………………………… 42 4.19 Figure …………………………………………………………………………………… 42 4.20 Figure …………………………………………………………………………………… 43 4.21 Figure …………………………………………………………………………………… 43 4.22 Figure …………………………………………………………………………………… 44 
4.23 Figure …………………………………………………………………………………… 44 4.24 Figure …………………………………………………………………………………… 45 4.25 Figure …………………………………………………………………………………… 46 4.26 Figure …………………………………………………………………………………… 46 4.27 Figure …………………………………………………………………………………… 47 4.28 Figure …………………………………………………………………………………… 47 4.29 Figure …………………………………………………………………………………… 48 
4.30 Figure …………………………………………………………………………………… 48 
5.1 Figure …………………………………………………………………………………… 55 
5.2 Figure …………………………………………………………………………………… 55 5.3 Figure …………………………………………………………………………………… 56 
5.4 Figure …………………………………………………………………………………… 56 
5.5 Figure …………………………………………………………………………………… 56 
5.6 Figure …………………………………………………………………………………… 57 
5.7 Figure …………………………………………………………………………………… 58 
5.8 Figure …………………………………………………………………………………… 58 
5.9 Figure …………………………………………………………………………………… 59 
5.10 Figure …………………………………………………………………………………… 60 
5.11 Figure …………………………………………………………………………………… 60 
5.12 Figure …………………………………………………………………………………… 61 
5.13 Figure …………………………………………………………………………………… 61 
5.14 Figure …………………………………………………………………………………… 62 
5.15 Figure …………………………………………………………………………………… 62 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 	 
AutoQuest 
AN INTELLIGENT AUTOMATIC QUESTION PAPER GENERATOR SYSTEM 
Gaurav Keswani , Amir Ahsan , Prateek Kushwaha | Project Report | June 1, 2019 
 
CHAPTER 1: INTRODUCTION 
 
1.1 INTRODUCTION OF AUTOQUEST 
 
The "Automatic Question Paper Generator" has been developed to override the problems prevailing in the practicing manual system. This software is supported to eliminate and, in some cases, reduce the hardships faced by this existing system. Moreover, this system is designed for the particular need of the company to carry out operations in a smooth and effective manner. 
 
The application is reduced as much as possible to avoid errors while entering the data. It also provides error message while entering invalid data. No formal knowledge is needed for the user to use this system. Thus, by this all it proves it is user-friendly. Automatic Question Paper Generator, as described above, can lead to error free secure, reliable and fast management system. It can assist the user to concentrate on their other activities rather to concentrate on the record keeping. Thus, it will help organization in better utilization of resources. 
 
Every organization, whether big or small, has challenges to overcome and managing the information of Course, Branch, Question, Subject, Semester. Every Automatic Question Paper Generator has different Branch needs; therefore, we design exclusive employee management systems that are adapted to your managerial requirements. This is designed to assist in strategic planning, and will help you ensure that your organization is equipped with the right level of information and details for your future goals. Also, for those busy executives who are always on the go, our systems come with remote access features, which will allow you to manage your workforce anytime, at all times. These systems will ultimately allow you to better manage resources. 
 
The purpose of Automatic Question Paper Generator is to automate the existing manual system by the help of computerized equipment’s and full-fledged computer software, fulfilling their requirements, so that their valuable data/information can be stored for a longer period with easy accessing and manipulation of the same. The required software and hardware are easily available and easy to work with Automatic Question Paper Generator, as described above, can lead to error free secure, reliable and fast management system. It can assist the user to concentrate on their other activities rather to concentrate on the record keeping. Thus, it will help organization in better utilization of resources. The organization can maintain computerized records without redundant entries. That means that one need not be distracted by information that is not relevant, while being able to reach the information. 
 
The aim is to automate its existing manual system by the help of computerized equipment's and fullfledged computer software, fulfilling their requirements, so that their valuable data/information can be stored for a longer period with easy accessing and manipulation of the same. Basically, the project describes how to manage for good performance and better services for the clients. 
 
1.1.1 Objective of Project on Automatic Question Paper Generator: 
 
The main objective of the Project on Automatic Question Paper Generator is to manage the details of 
Branch, Course, Difficult Level, Question, Semester. It manages all the information about Branch, Subject, Semester, Branch. The project is totally built at administrative end and thus only the administrator is guaranteed the access. The purpose of the project is to build an application program to reduce the manual work for managing the Branch, Course, Subject, Difficult Level. It tracks all the details about the Difficult Level, Question, Semester. 
 
1.1.2 Functionalities provided by Automatic Question Paper Generator are as follows: 
•	Provides the searching facilities based on various factors. Such as Branch, Difficulty Level, Question, Semester 
•	Automatic Question Paper Generator also manage the Subject details online for Question details, Semester details, Branch. 
•	It tracks all the information of Course, Subject, Question etc 
•	Manage the information of Course 
•	Shows the information and description of the Branch, Difficult Level 
•	To increase efficiency of managing the Branch, Course 
•	It deals with monitoring the information and transactions of Question. 
•	Manage the information of Branch 
•	Editing, adding and updating of Records is improved which results in proper resource management of Branch data. 
•	Manage the information of Question 
•	Integration of all records of Semester. 
 
 
 
 
1.1.3 Scope of the project Automatic Question Paper Generator 
 
It may help collecting perfect management in details. In a very short time, the collection will be obvious, simple and sensible. It will help a person to know the management of passed year perfectly and vividly. It also helps in current all works relative to Automatic Question Paper Generator. It will be also reduced the cost of collecting the management collection procedure will go on smoothly. Our project aims at Business process automation, ie. we have tried to computerize various processes of Automatic Question Paper Generator. 
•	In computer system the person has to fill the various forms number of copies of the forms can be easily generated at a time. 
•	In computer system, it is not necessary to create the manifest but we can directly print it, which saves our time. 
•	To assist the staff in capturing the effort spent on their respective working areas 
•	To utilize resources in an efficient manner by increasing their productivity through automation 
•	The system generates types of information that can be used for various purposes 
•	It satisfy the user requirement 
•	Be easy to understand by the user and operator 
•	Be cast to operate 
•	Have a good user interface 
•	Bo expandable 
•	Delivered on schedule within the budget 
 
1.1.4 Reports of Automatic Question Paper Generator: 
 
•	It generates the report on Branch, Course, Subject 
•	Provide filter reports on Difficult Level, Question, Semester 
•	You can easily export PDF for the Branch Subject, Question 
•	Application also provides excel export for Course, Difficult Level, Semester 
•	You can also export the report into csv format for Branch, Course, Semester 
 
 
 
1.2 Modules of Automatic Question Paper Generator: 
 
•	Branch Management Module: Used for managing the Branch details 
•	Semester Module: Used for managing the details of Semester 
•	Subject Module: Used for managing the details of Subject 
•	Course Management Module: Used for managing the information and details of   the Course 
•	Difficult Level Module: Used for managing the Difficult Level details 
•	Question Module: Used for managing the Question Information 
•	Login Module: Used for managing the login details 
•	Users Module: Used for managing the users of the system 
 
1.2.1 Input Data and Validation of Project on AutoQuest 
 
•	All the fields such as Branch, Difficult Level, Semester are validated and does not take invalid values 
•	Each form for Branch, Course, Subject can not accept blank value fields 
•	Avoiding errors in data 
•	Controlling amount of input 
•	Integration of all the modules/forms in the system 
•	Preparation of the test cases. 
•	Preparation of the possible test data with all the validation checks. 
•	Actual testing done manually 
•	Recording of all the reproduced errors. 
•	Modifications done for the errors found during testing • Prepared the test result scripts after rectification of the errors 
•	Functionality of the entire module/forms. 
•	Validations for user input 
•	Checking of the Coding standards to be maintained during coding. 
 
 
 
 
 
1.3 Software Quality Plan: 
 
The software quality plan we will use the following SQA Strategy 
•	In the first step, we will select the test factors and rank them. The selected test factors such as reliability, maintainability, portability or etc., will be placed in the matrix according to their ranks. 
•	The second step is for identifying the phases of the development process the phase should be recorded in the matrix 
•	The third step is that identifying the business risks of the software deliverables. The risks will be ranked into three ranks such as high, medium and low. 
 
1.3.1 Features of AutoQuest: 
•	Product and Component based 
•	Creating & Changing Issues at ease 
•	Query Issue List to any depth 
•	Reporting & Charting in more comprehensive way 
•	User Accounts to control the access and maintain security 
•	Simple Status & Resolutions 
•	Multi-level Priorities & Severities 
•	Targets & Milestones for guiding the programmers 
•	Attachments & Additional Comments for more information 
•	Various level of reports available with a lot of filter criteria's 
•	It contains better storage capacity 
•	Accuracy in work 
•	Easy Fast retrieval of information 
•	Well-designed reports 
•	Decrease the load of the person involve in existing manual system 
•	Access of any information individually 
•	Work becomes very speedy 
•	Easy to update information 
 
 
 
 
1.4 Software Requirement Specification: 
 
The Software Requirements Specification is produced at the culmination of the analysis task. The function and performance allocated to software as part of system engineering are refined by establishing a complete information description, a detailed functional and behavioral description, an indication of performance requirements and design constraints, appropriate validation criteria, and other data pertinent to requirements. 
The proposed system has the following requirements: 
•	System needs store information about new entry of Branch. 
•	System needs to help the internal staff to keep information of Course and find them as per various queries 
•	System need to maintain quantity record 
•	System need to keep the record of Difficult Level. 
•	System need to update and delete the record. 
 
1.4.1 Identification of need: 
 
The old manual system was suffering from a series of drawbacks. Since whole of the system was to be maintained with hands the process of keeping, maintaining and retrieving the information was very tedious and lengthy. The records were never used to be in a systematic order. there used to be lots of difficulties in associating any particular transaction with a particular context. If any information was to be found it was required 
to go through the different registers, documents there would never exist anything like report generation. There would always be unnecessary consumption of time while entering records and retrieving records. One more problem was that it was very difficult to find errors while entering the records. Once the records were entered it was very difficult to update these records. 
 
The reason behind it is that there is lot of information to be maintained and have to be kept in mind while running the business For this reason we have provided features Present system is partially automated (computerized), actually existing system is quite laborious as one has to enter same information at three different places. Following points should be well considered: 
•	Documents and reports that must be provided by the new system: there can also be few reports, which can help management in decision-making and cost controlling, but since these reports 
do not get required attention, such kind of reports and information were also identified and given required attention. 
•	Details of the information needed for each document and report 
•	The required frequency and distribution for each document. 
•	Probable sources of information for each document and report 
•	With the implementation of computerized system, the task of keeping records in an organized manner will be solved. The greatest of all is the retrieval of information, which will be at the click of the mouse. So the proposed system helps in saving the time in different operations and making information flow easy giving valuable reports. 
 
 
1.5 FEASIBILITY 
 
After doing the project Automatic Question Paper Generator, study and analyzing all the existing or required functionalities of the system, the next task is to do the feasibility study for the project. All projects are feasible - given unlimited resources and infinite time. 
Feasibility study includes consideration of all the possible ways to provide a solution to the given problem. The proposed solution should satisfy all the user requirements and should be flexible enough so that future changes can be easily done based on the future upcoming requirements. 
 
1.5.1 Economical Feasibility 
This is a very important aspect to be considered while developing a project. We decided the technology based on minimum possible cost factor. 
•	All hardware and software cost have to be borne by the organization. 
•	Overall, we have estimated that the benefits the organization is going to receive from the proposed system will surely overcome the initial costs and the later on running cost for system. 
 
1.5.2	Technical Feasibility 
 
This included the study of function performance and constraints that may affect the ability to achieve an acceptable system. For this feasibility study, we studied complete functionality to be provided in the system, as described in the System 
Requirement Specification (SRS), and check if everything was possible using different type of frontend and backend platforms 
 
1.5.3	Operational Feasibility 
 
No doubt the proposed system is fully GUI based that is very user friendly and all inputs to be taken all self-explanatory even to a layman. Besides, a proper training has been conducted to let know the essence of the system to the users so that they feel comfortable with new system. As far our study is concerned the clients are comfortable and happy as the system has cut down their loads and doing. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
CHAPTER 2: ANALYSIS  
 
 
2.1 System Design of AutoQuest 
 
In this phase, a logical system is built which fulfils the given requirements. Design phase of software development deals with transforming the client's requirements into a logically working system. 
Normally, design is performed in the following in the following two steps: 
 
•	Primary Design Phase:  
In this phase, the system is designed at block level. The blocks are created on the basis of analysis done in the problem identification phase. Different blocks are created for different functions emphasis is put on minimizing the information flow between blocks. Thus, all activities which require more interaction are kept in one block. 
 
•	Secondary Design Phase: 
In the secondary phase the detailed design of every block is performed The general tasks involved in the design process are the following: 
•	Design various blocks for overall system processes. 
•	Design smaller, compact and workable modules in each block 
•	Design various database structures. 
•	Specify details of programs to achieve desired functionality. 
•	Design the form of inputs, and outputs of the system. 
•	Perform documentation of the design. 
•	System reviews. 
 
 
 
 
 
 
 
 
 
2.1.1 User Interface Design 
 
User Interface Design is concerned with the dialogue between a user and the computer. It is concerned with everything from starting the system or logging into the system to the eventually presentation of desired inputs and outputs. The overall flow of screens and messages is called a dialogue. 
 
The following steps are various guidelines for User Interface Design: 
•	The system user should always be aware of what to do next 
•	The screen should be formatted so that various types of information, instructions and messages always appear in the same general display area. 
•	Message instructions or information should be displayed long enough to allow the system user to read them 
•	Use display attributes sparingly 
•	Default values for fields and answers to be entered by the user should be 
•	specified 
•	6 A user should not be allowed to proceed without correcting an error 
•	The system user should never get an operating system message or fatal error 
 
2.1.2 Preliminary Product Description: 
 
The first step in the system development life cycle is the preliminary Investigation to determine the feasibility of the system. The purpose of the preliminary investigation is to evaluate project requests. It is not a design study nor does it include the collection of details to describe the business system in all respect. Rather, it is the collecting of information that helps committee members to evaluate the merits of the project request and make an informed judgment about the feasibility of the proposed project. 
Analysts working on the preliminary Investigation should accomplish the following objectives: 
 
•	Clarify and understand the project request 
•	Determine the size of the project. 
•	Assess costs and benefits of alternative approaches 
•	Determine the technical and operational feasibility of alternative approaches 
•	Report the findings to management with recommendations outlining the acceptance or rejection of the proposal 
 
Benefit to Organization 
The organization will obviously be able to gain benefits such as savings in operating cost reduction in paperwork better utilization of human resources and more presentable image increasing goodwill. 
 
The Initial Cost 
The initial cost of setting up the system will include the cost of hardware software (OS, add on software, utilities) & labour (setup & maintenance) The same has to bear by the organization. 
 
Running Cost 
Besides, the initial cost the long-term cost will include the running cost for the system including the 
AMC, stationary charges cost for human resources, cost for update/renewal of various related software. 
 
Need for Training 
The users along with the administrator need to be trained at the time of implementation of the system for smooth running of the system. The client will provide the training site. 
We talked to the management people who were managing the financial issues of the center, the staff who were keeping the records in lots of registers and the reporting manager regarding their existing system, their requirements and their expectations from the new proposed system. Then, we did the system study of the entire system based on their requirements and the additional features they wanted to incorporate in this system. 
Reliable, accurate and secure data was also considered to be a complex task without this proposed system. Because there was no such record for keeping track of all the activities, which was done by the Automatic Question Paper Generator on the daily basis. 
The new system proposed and then developed by me will ease the task of the organization in consideration It will be helpful in generating the required reports by the staff, which will help them to track their progress and services. Thus, it will ease the task of Management to a great extent as all the major activities to be performed, are computerized through this system. 
 
 
 
 
 
 
 
 
2.2 Implementation Methodology: 
 
Model View Controller or MVC as it is popularly called, is a software design pattern for developing web applications. A Model View Controller pattern is made up of the following three parts 
•	Model-The lowest level of the pattern which is responsible for maintaining data 
•	View- This is responsible for displaying all or a portion of the data to the user 
•	Controller-Software Code that controls the interactions between the Model and View 
MVC is popular as it isolates the application logic from the user interface layer and supports separation of concerns. Here the Controller receives all requests for the application and then works with the Model to prepare any data needed by the View. The View then uses the data prepared by the Controller to generate a final presentable response. The MVC abstraction can be graphically represented as follows. 
 
 
 
  
                                         Fig 2.1 MVC (Model View Controller) Diagram 
 
 
 
 
 
2.3 Project Planning: 
 
Software project plan can be viewed as the following: 
 
•	Within the organization: How the project is to be implemented? What are various constraints (time, cost, staff)? What is market strategy? 
 
•	With respect to the customers: Weekly or timely meetings with the customer with presentation on status reports. Customers feedback is also taken and further modification and developments are done. Project milestones and deliverables are also presented to the customer 
 
For a successful software project, the following steps can be followed: 
•	Select a project o Identifying project's aims and objectives 	 o Understanding requirements and specification o Methods of analysis, design and implementation o Testing techniques o Documentation 
•	Project milestones and deliverables 
•	Budget allocation o Exceeding limits within control 
•	Project Estimates o Cost o Time 
o Size of code o Duration 
•	Resource Allocation o Hardware o Software 
o Previous relevant project information o Digital Library 
 
 
 
2.4 Cost estimation of the project: 
 
Software cost comprises a small percentage of overall computer-based system cost. There are a number of factors, which are considered, that can affect the ultimate cost of the software such as - human, technical, Hardware and Software availability etc 
 
The main point that was considered ring the cost estimation of project was its sizing. In spite of complete software sizing, function point and approximate lines of code were also used to "size" each element of the Software and their costing. 
 
The cost estimation done by me for Project also depend upon the baseline metrics collected from past projects and these were used in conjunction with estimation variables to develop cost and effort projections. 
 
We have basically estimated this project mainly on two bases - 
 
•	Effort Estimation: This refers to the total man-hours required for the development of the project. 
It even includes the time required for doing documentation and user manual. 
 
•	Hardware Required Estimation-This includes the cost of the PCs and the hardware cost required for development of this project. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
2.5 TOOL/PLATFORMS AND HARDWARE/SOFTWARE REQUIREMENTS 
 
Software Requirements: 
 
Name of component 	Specification 
Operating System 	Windows 7, Windows 10, Linux and Mac 
Language 	Node JS, Python3.6, JavaScript 
Database 	MongoDB, mLAB 
Browser 	Firefox, Chrome, IE10, Opera, Safari 
Web Server 	Cloud9, Heroku (AWS) 
Software Development Kit 	Express, Passport, python 2.7 and above 
Scripting Language Enable 	JavaScript 
Database Driver 	Mongoose 
Table 2.1 
 
Hardware Requirements: 
 
Name of component 	Specification 
Processor 	Pentium 4 and above 
RAM 	1GB 
Hard disk 	20GB 
Monitor 	15” color monitor 
Keyboard 	122 keys 
Table 2.2 
 
 
 
 
 
 
 
 
 
2.6 System Analysis 
 
System analysis is a process of gathering and interpreting facts, diagnosing problems and the information about the Automatic Question Paper Generator to recommend improvements on the system. It is a problem-solving activity that requires intensive communication between the system users and system developed System analysis or study is an important phase of any system development process. The system is studied to the minutest detail and analyzed. The system analyst plays the role of the interrogator and dwells deep into the working of the present system. The system is viewed as a whole and the input to the system are identified. The outputs from the organizations are traced to the various processes. System analysis is concerned with becoming aware of the problem, identifying the relevant and decisional variables analyzing and synthesizing the various factors and determining an optimal or at least a satisfactory solution or program of action. A detailed study of the process must be made by various techniques like interviews, questionnaires etc. The data collected by these sources must be scrutinized to arrive to a conclusion. The conclusion is an understanding of how the system functions This system is called the existing system Now the existing system is subjected to close study and problem areas are identified. 
The designer now functions as a problem solver and tries to sort out the difficulties that the enterprise faces the solutions are given as proposals. The proposal is then weighed with the existing system analytically and the best one is selected. The proposal is presented to the user for an endorsement by the user. The proposal is reviewed on user request and suitable changes are made. This is loop that ends as soon as the user is satisfied with proposal. Preliminary study is the process of gathering and interpreting facts, using the information for further studies on the system. Preliminary study is problem solving activity that requires intensive communication between the system users and system developers. It does various feasibility studies. In these studies, a rough figure of the system activities can be obtained from which the decision about the Strategies to be followed for effective system study and analysis can be taken. 
 
 
 
 
 
 
 
 
 
2.7 COMPARISON OF EXISTING VS PROPOSED SYSTEM 
 
2.7.1 Existing System of Automatic Question Paper Generator 
 
In the existing system the exams are done only manually but in proposed system we have to computerize the exams using this application. 
•	Lack of security of data. 
•	More man power 
•	Time consuming 
•	Consumes large volume of pare work 
•	Needs manual calculations. 
•	No direct role for the higher officials 
 
Proposed System of Automatic Question Paper Generator 
 
The aim of proposed system is to develop a system of improved facilities. The proposed system can overcome all the limitations of the existing system. The system provides proper security and reduces the manual work. 
•	Security of data 
•	Ensure data accuracy. 
•	Proper control of the higher officials 
•	Minimize manual data entry 
•	Minimum time needed for the various processing. 
•	Greater efficiency 
•	Better service 
•	User friendliness and interactive. 
•	Minimum time required 
 
 
 
 
 
 
 
CHAPTER 3: DESIGN OF AUTOQUEST 
 
 
3.1 PROJECT PROFILE: 
There has been continuous effort to develop tools, which can ease the process of software development. But, with the evolving trend of different programming paradigms today's software developers are really challenged to deal with the changing technology. Among other issues, software re-engineering is being regarded as an important process in the software development industry. One of the major tasks here is to understand 
software systems that are already developed and to transform them to a different software environment Generally, this requires a lot of manual effort in going through a program that might have been developed by another programmer. This project makes a novel attempt to address the issued of program analysis and generation of diagrams which can depict the structure of a program in a better way. Today, UML is being considered as an industrial standard for software engineering design process It essential provides several diagramming tools that can express different aspects characteristics of program such as: 
 
Use cases: Elicit requirement from users in meaningful chunks. Construction planning is built around delivering some use cases each interaction basis for system testing. 
 
Class diagrams: shows static structure of concepts, types and class. Concepts how users think about the world; type shows interfaces of software components; classes shows implementation of software components. 
 
Interaction diagrams: shows how several objects collaborate in single use case 
 
Package diagram: show group of classes and dependencies among them 
 
State diagram: show how single object behaves across many use cases 
 
Activity diagram: shows behavior with control structure. Can show many objects over many uses, many objects in single use case, or implementations methods encourage parallel behavior, etc. 
The end product of thin project is a comprehensive tool that can parse any vb.net program and extract most of the object-oriented features Inherent in the program such as polymorphism, inheritance, encapsulation and abstraction. 
 
What is UML? 
UML stands for Unified Modeling Language is the successor to the wave of Object-Oriented Analysis and Design (OOA&D) methods that appeared in the late 80's. It most directly unifies the methods of Booch, Rumbaugh (OMT) and Jacobson The UML is called a modeling language, not a method. Most methods consist at least in principle of both a modeling language and a process The Modeling language is that notation that methods used to express design. 
 
Notations and meta-models 
The notation is the graphical stuff; it is the syntax of the modeling language For instance, class diagram notation defines how items are concepts such as class association, and multiplicity is represented. These are  
 
Class Diagram: The class diagram technique has become truly central within object oriented methods Virtually every method has included some variation on this technique. Class diagram is also subject to the greatest range of modeling concept. Although the basic elements are needed by everyone, advanced concepts are used less often, A class diagram describes the types of objects in the system and the various kinds of static relationship that exist among them There are two principal kinds of static relationship: 
•	Association 
•	Sublime 
Class diagram also show the attributes and operations of a class and the constraints that apply to the way objects are connected. 
 
Association: Association represent between instances of class. From the conceptual perspective, association represents conceptual relations between classes. Each association has two roles. Each role is a direction on the association. A role also has multiplicity, which is a indication of how many object may participate in the given relationship 
 
Generalization: A typical example of generalization evolves the personal and corporate customer of a business. They have differences but also many similarity. The similarities can be placed in generalization with personal customer and corporate customer subtype. 
 
Aggregation: Aggregation is the part of relationship. It is like saying a car has engine and wheels as its parts. This sounds good, but difficult thing is considering, what is the difference is aggregation and association 
 
Interaction: Interaction diagrams are models that describes how groups of objects collaboration in some behavior. Typically, an interaction diagram captures the behavior a single use cases. The diagram shows a number of example objects and the messages that are passed between these objects in use cases. These are following approaches with simple use case that exhibits the following behavior. Objects can send a message to another. Each message is checks with given stock item There are two diagrams Sequence and Collaboration diagram. 
 
Package Diagram: One of the oldest questions in software methods is: how do you break down a large system into smaller systems? It becomes difficult to understand and the changes we make to them. Structured methods used functional decomposition in which the overall system was mapped as a function broken down into sub function, which is further broken down into sub function and so forth. The separation of process data is gone, functional decomposition is gone, but the old question is still remaining.  
One idea is to group the classes together into higher-level unit. This idea, applied very loosely, appears in many objects. In UML, this grouping mechanism is package. The term package diagram for a diagram that shows packages of classes and the dependencies among them. 
A dependency exists between two elements if changes to the definition of one element may cause to other. With classes, dependencies exist for various reasons: one class sends a message to another; one class has another as part of its data; one class mentions another as a parameter to an operation. 
 
State diagram: State diagram are a familiar technique to describe the behavior of a system. They describe all the possible states a particular object can get into and how the objects state changes as a result of events that reach the objects. In most OO technique, state diagrams are drawn for a single class to show the lifetime behavior of a single object.  
 
 
 
 
 
 
3.2 Use Case Model of the Project: 
The use case model for any system consists of use cases". Use cases represent different ways in which the system can be used by the user. A simple way to find all the use case of a system is to ask the questions What the user can do using the system? The use cases partition the system behavior into transactions such that each transaction performs some useful action from the user’s point of view. 
 
The purpose of the use case to define a piece of coherent behavior without revealing the internal structure of the system. A use case typically represents a sequence of interaction between the user and the system. These interactions consist of one main line sequence is represent the normal interaction between the user and the system. The use case model is an important analysis and design artifact (task). Use cases can be represented by drawing a use case diagram and writing an accompany text elaborating the drawing 
 
In the use case diagram, each use case is represented by an ellipse with the name of use case written inside the ellipse. All the ellipses of the system are enclosed with in a rectangle which represents the system boundary. The name of the system being modeled appears inside the rectangle. The different users of the system are represented by using stick person icon. The stick person icon is normally referred to as an Actor. The line connecting the actor and the use cases is called the communication relationship, when a stick person icon represents an external system it is annotated by the stereo type<external system>> 
 
3.3 Data Flow Diagram: 
Data flow diagram is the starting point of the design phase that functionally decomposes the requirements specification. A DFD consists of a series of bubbles joined by lines The bubbles represent data transformation and the lines represent data flows in the system. A DFD describes what data flow rather than how they are processed, so it does not hardware, software and data structure. 
 
A data-flow diagram (DFD) is a graphical representation of the "flow" of data through an Information system. DFDs can also be used for the visualization of data Drocessing (structured design). A data flow diagram (DFD) is a significant modeling technique for analyzing and constructing information processes OF literally means an illustration that explains the course or movement of Information in a process. DFD illustrates this flow of Information in a process based on the inputs and outputs. A DFD can be referred to as a Process Model 
 
The data flow diagram is a graphical description of a system's data and how to Process transform the data is known as Data Flow Diagram (DFD) Unlike details flow chart, DFDs don't supply detail descriptions of modules that graphically describe a system's data and how the data interact with the system, Data flow diagram number of symbols and the following symbols are of by DeMarco 
  
                                                                 Fig 3.1 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
3.4 Entity Relationship Diagram 
E-R Model is a popular high-level conceptual data model. This model and its variations are frequently used for the conceptual design of database application and many database design tools employ its concept. 
A database that confirms to an E-R diagram can be represented by a collecton of tables in the relational system. The mapping of ER diagram to the entities are: 
•	Attributes 
•	Relations o Many-to-many o Many-to-one o One-to-many o One-to-one 
•	Weak entities 
•	Subtype and supertype 
 
The entities and their relationships between them are shown using the following Conventions. • An entity is shown in rectangle 
 
•	A diamond represents the relationship among number of entities 
•	The attributes shown as ovals are connected to the entity or relationship by Lines. 
•	Diamond, oval and relationships are labeled. 
•	Model is an abstraction process that hides super details while highlighting details relation to application at end. 
•	A data model is a mechanism that provides this abstraction for database application 
•	Data modeling is used for representing entities and their relationship in the database 
•	Entities are the basic units used in modeling database entities can have concrete existence or constitute ideas or concepts. 
•	Entity type or entity set is a group of similar objects concern to an organization for which it maintain data 
•	Properties are characteristics of an entity also called as attributes 
•	A key is a single attribute or combination of 2 or more attributes of an entity set is used to identify one or more instances of the set 
•	In relational model we represent the entity by a relation and use tuples to represent an instance of the entity 
•	Relationship is used in data modeling to represent in association between an entity set 
•	An association between two attributes indicates that the values of theassociated attributes are independent 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
3.5 SCREENSHOTS OF DESIGN: 
 
1.Landing Page 
  
Fig 3.2 
 
2.Click On Get Started 
  
Fig 3.3 
3.	You can view more about AutoQuest by clicking on Read more 
 
  
Fig 3.4 
 
4.	Login Design 
 
  
Fig 3.5 
 
 
 
5.	Signup Design 
 
  
Fig 3.6 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
6.Add Question Interface Design 
 
  
 
Fig 3.7 
7.View Question Bank Interface Design 
 
  
Fig 3.8 
 
8.Click on UserName to return to Dashboard 
 
 
 
 
 
CHAPTER 4: CODING OF AUTOQUEST 
 
The code for the AutoQuest Project was created in various versions where with each version additional functionalities were added.  
The screenshots of the versions of the codes is shown as below: 
 
  
Fig 4.1 AutoQuest Versions 
 
V1 – Here only the landing page was developed in this version. 
V3 – Here the second page of dashboard and Read More functionalities were added with routes created in NodeJS 
V3.1 – Modified the dashboard adding CSS properties to look it more amenable V3.2 – Modified the dashboard with animation and hover effects. 
V4 – Created the main login and signup page with authentication from email. 
V5 – Connected the mongo DB database from third party server mLAB .  
V6 – Created the final working version of project of generating the pdf format of Question Paper by using ML and AI algorithms with varying difficulty pattern. 
 
 
Landing Page Code: 
 
  
Fig 4.2 
 
 
 
Header Page Code: 
 
  
Fig 4.3 
 
 
 
 
 
Footer Page Code: 
 
  
Fig 4.4 
 
Intro Page Code: 
 
  
Fig 4.5 
 
Dashboard Page Code: 
 
  
Fig 4.6.1 
 
 
  
Fig 4.6.2 
 
 
 
Signup/Login Page Code: 
 
  
Fig 4.7.1 
  
Fig 4.7.2 
 
 
Question Bank Page Code: 
 
  
Fig 4.8.1 
 
  
Fig 4.8.2 
 
 
 
Connecting NodeJS with Python Cross Platform Page Code: 
 
  
Fig 4.9.1 
  
Fig 4.9.2 
 
 
 
Terminal Add Questions/Subjects Python Code: 
 
  
Fig 4.10 
 
AutoQuest Generator PDF/DOCx Format Code: 
 
  
Fig 4.11 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Step by Step Terminal View of Question Paper Generation Screenshots: 
 
Step1: Enter the subject name.  
 
  
Fig 4.12 
 
Step2: Enter ‘Yes’ to add more questions else ‘No’. 
 
  
Fig 4.13 
Step3: Enter the question. 
 
  
Fig 4.14 
 
Step4: After Adding Questions again choose “Yes/No” as in previous steps. 
 
 
Fig 4.15
Step5: Press ‘No’ when you are finished adding Questions in the Question Bank     through terminal. 
 
  
Fig 4.16 
Step6: After adding questions run the generator program to generate a portable and documentable format of questions list for a particular subject . 
 
  
Fig 4.17
PDF Format: 
 
  
Fig 4.18 
 
Text/Docx Format: 
 
 
Fig 4.19
SNAPSHOTS OF HEROKU (AWS) CLOUD9 SERVER : 
 
  
Fig 4.20 
 
 
  
Fig 4.21 
 
UPLOADED PROJECT ON GITHUB: 
 
  
Fig 4.22 
 	 
 
 Done 12 commits and merged various branches for different versions of the Project. 
 
 
Fig 4.23 
Deployed Open Source for various Pull Requests and Merged Them. 
 
  
Fig 4.24 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Database Used MongoDB in server mLAB: 
Collections 
  
Fig 4.25 
 
JSON Storage 
 
  
Fig 4.26 
Requirements: 
 
  
Fig 4.27 
 
Documents: 
 
  
Fig 4.28 
 
Database Storage in Object Form: 
 
  
Fig 4.29 
 
  
Fig 4.30 
 
 
CHAPTER 5: TESTING 
 
5.1 Security Testing of Project: 
 
Testing is vital for the success of any software. no system design is ever perfect. Testing is also carried in two phases. First phase is during the software engineering that is during the module creation. Second phase is after the completion of software. This is system testing which verifies that the whole set of programs hanged together 
 
5.1.1 White Box Testing: 
 
In this technique, the close examination of the logical parts through the software are tested by cases that exercise species sets of conditions or loops. all logical parts of the software checked once. errors that can be corrected using this technique are typographical errors, logical expressions which should be executed once may be getting executed more than once and error resulting by using wrong controls and loops, When the box testing tests all the independent part within a module a logical decisions on their true and the false side are exercised, all loops and bounds within their operational bounds were exercised and internal data structure to ensure their validity were exercised once . 
 
5.1.2 Black Box Testing: 
 
This method enables the software engineer to device sets of input techniques that fully exercise all functional requirements for a program. black box testing tests the input the output and the external data. it checks whether the input data is correct and whether we are getting the desired output . 
 
5.1.3 Alpha Testing 
 
Acceptance testing is also sometimes called alpha testing. Be spoke systems are developed for a single customer. The alpha testing proceeds until the system developer and the customer agree that the provided system is an acceptable implementation of the system requirements. 
 
5.1.4 Beta Testing: 
 
On the other hand, when a system isto be marked as a software product, another process called beta testing is often conducted. During beta testing, a system is delivered among a number of potential users who agree to use it. The customers then report problems to the developers. This provides the product for real use and detects errors which may not have been anticipated by the system developers. 
 
5.1.5 Unit Testing 
Each module is considered independently. it focuses on each unit of software as implemented in the source code; it is white box testing. 
 
5.1.6 Integration Testing: 
Integration testing aims at constructing the program structure while at the same constructing tests to uncover errors associated with interfacing the modules are integrated by using the top down approach. 
 
5.1.7 Validation Testing: 
Validation testing was performed to ensure that all the functional and performance requirements are met. 
 
5.1.8 System Testing 
It is executing programs to check logical changes made in it with intention of finding errors a system is tested for online response volume of transaction, recovery from failure etc. System testing is done to ensure that the system satisfies all the user requirements 
 
 
 
 
 
 
 
 
5.2 Implementation and Software Specification Testings 
 
Detailed Design of Implementation 
 
This phase of the systems development life cycle refines hardware and software specifications, establishes programming plans, trains users and implements extensive testing procedures, to evaluate design and operating specifications and/or provide the basis for further modification. 
 
Technical Design 
 
This activity builds upon specifications produced during new system design, adding detailed technical specifications and documentation. 
 
Test Specifications and Planning 
 
This activity prepares detailed test specifications for individual modules and programs, job streams, subsystems, and for the system as a whole. 
 
Programming and Testing 
This activity encompasses actual development, writing, and testing of program units or modules. 
 
 
User Training 
This activity encompasses writing user procedure manuals, preparation of user training materials, conducting training programs and testing procedures 
 
Acceptance Test 
A final procedural review to demonstrate a system and secure user approval before a system becomes operational. 
 
Installation Phase 
In this phase the new Computerized system is installed, the conversion to new procedures is fully implemented, and the potential of the new system is explored 
 
System Installation 
The process of starting the actual use of a system and training user personnel in its operation 
 
Review Phase 
 
This phase evaluates the successes and failures during a systems development project, and to measure the results of a new Computerized Trans System in terms of benefits and savings projected at the start of the project. 
 
Development Recap 
A review of a project immediately after completion to find successes and potential problems in future work 
 
Post-Implementation Review 
A review, conducted after a new system has been in operation for some time, to evaluate actual system performance against original expectations and projections for cost-benefit improvements Also identifies maintenance projects to enhance or improve the system 
 
THE STEPS IN THE SOFTWARE TESTING 
The steps involved during Unit testing are as follows: 
 
•	Preparation of the test cases, 
•	Preparation of the possible test data with all the validation checks 
•	Complete code review of the module 
•	Actual testing done manually 
•	Modifications done for the errors found during testing 
•	Prepare the test result scripts 
 
The unit testing done included the testing of the following items 
 
•	Functionality of the entire module/forms. 
•	Validations for user input 
•	Checking of the Coding standards to be maintained during coding. 
•	Testing the module with all the possible test data. 
•	Testing of the functionality involving all type of calculations etc 
•	Commenting standard in the source files. 
 
After completing the Unit testing of all the modules, the whole system is integrated with all its dependencies in that module. While System Integration, We integrated the modules one by one and tested the system at each step. This helped in reduction of errors at the time of the system . 
 
The steps involved during System testing are as follows 
 
•	Integration of all the modules/forms in the system. 
•	Preparation of the test cases. 
•	Preparation of the possible test data with all the validation checks 
•	Actual testing done manually. 
•	Recording of all the reproduced errors 
•	Modifications done for the errors found during testing 
•	Prepared the test result scripts after rectification of the errors. 
 
 
The System Testing done included the testing of the following items: 
 
•	Functionality of the entire system as a whole. 
•	User Interface of the system 
•	Testing the dependent modules together with all the possible test data scripts. 
•	Verification and Validation testing. 
•	Testing the reports with all its functionality 
 
After the completion of system testing, the next following phase was the Acceptance Testing. Clients at their end did this and accepted the system with appreciation. Thus, we reached the final phase of the project delivery 
 
There are other six tests. which fall under special category. They are described below: 
 
•	Peak Load Test It determines whether the system will handle the volume of activities that occur when the system is at the peak of ils processing demand. For example, test the system by activating all terminals at the same time. 
•	Storage Testing: It determines the capacity of the cistern to store transaction data on a disk or in other files. 
•	Performance Time Testing: it determines the length of time system used by the system to process transaction data. This test is conducted prior to implementation to determine how long it takes to get a response to an inquiry, make a backup copy of a file, or send a transmission and get a response 
•	Recovery Testing: This testing determines the ability of user to recover data or re-start system after failure. For example, load backup copy of data and resume processing without data or integrity loss. 
•	Procedure Testing determines the clarity of documentation on operation and uses of system by having users do exactly what manuals request. For example, powering down system at the end of week or responding to paper-out light on printer. 
•	Human Factors Testing: It determines how users will use the system when processing data or preparing reports. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
5.3 SCREENSHOTS OF SOFTWARE TESTING 
 
Testing whether Questions are added to the Question Bank Automatically. 
 
 
Initial Questions in the Question Bank. Each newly added question will join at the last row of Question Bank. 
 
 
  
Fig 5.1 
  	 
 
 
Click on Add Questions and This window will appear. 
 
  
Write the question of the subject, level of difficulty and unit along with the question. Fig 5.2 
 
  
Fig 5.3 
  
After Clicking on Submit Button A Flash Card Is generated showing that the question is added to the database. 
 
 
 
  
Fig 5.4 
 
Again, Open the Question Bank and you will see that the entered question is added at the last row of the database. Thus, Testing is done and is working properly for any number of questions the admin wants to add. 
 
  
Fig 5.5 
  
Testing whether Subjects which are not added in the database are added by the admin. 
 
 
The screenshots above(fig 5.5) show how the subject Algorithms gets added successfully in the database just below the questions of Computer Networks. 
 
Hence Testing for various subjects also proved correct results. 
 
 
 Testing whether Question Paper Generated is not repeated on consecutive generation. 
 
This is a screenshot of pdf generation from terminal window during first attempt . 
 
  
Fig 5.6 
The pdf question paper generated from first execution. 
 
  
Fig 5.7 
 
The second execution of pdf generation from terminal. 
 
  
Fig 5.8 
 
 
 
 
This is the second pdf generated from second execution of Generate Question Paper from AutoQuest. 
 
  
                                            Fig 5.9 
 
We can see that the questions generated after consecutive execution are different and questions will not get repeated. 
Thus, testing proved to be correct for this condition. 
 
 
 Testing whether Question Paper Can be generated with not enough questions in the database A proper error must be shown if there are not enough questions of a particular subject for it to be generated.  
Example:  
Given a question list screenshot of Operating System. 
 
  
Fig 5.10 
 
In the above Question Bank Of Operating System, there are not enough questions to generate a Question Paper. So, an appropriate message is shown by the terminal upon execution of the generation of such subjects. 
 
  
Fig 5.11 
 
e. Testing whether Sign In form is working properly and authenticated from the  database server.  
Initially we enter 
Email-id: ucer010@gmail.com    
Password: ucer 
Since the required details are not Sign Up initially and hence they are not in database so a JS alert pops up to Signup First. 
  
Fig 5.12 
 
 
 
 
Now we Sign Up with the following details: 
 
  
Fig 5.13 
After clicking on Signup button, we are redirected to dashboard page directly and we can login again by using the credentials used in Signup form. 
 
 
  
Fig 5.14 
 
 
 
After Sign In the name of user is displayed on top-right corner of AutoQuest WebApp. 
 
  
Fig 5.15 
Thus, we can see that the Authentication Tests are working properly for the project. 
 
 
 
 
 
 
 
 
CONCLUSION 
 
AutoQuest is an intelligent way for generating question paper of school and colleges. The main purpose of this application is to describe automatic question paper generator. This system is webbased as well as desktop-based application system with several features mainly producing unduplicated sets of exam paper. The result shows the potential proofs of employment of such algorithm for this type of system. Our future effort is to employ different types of randomization as well as in addition to question generation we can enhance the same software by making provision to produce questions from simple online text, which can be achieved using natural language processing algorithms 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Future Work 
 
In future enhancements, more features will be included to generate questions paper for online and offline MCQ examination. This will help in the cases where the examination pattern consists of only MCQ questions. This eliminate the problem of paper leak cases in the prestigious examinations. 
Thus, making the examination process more effective and secure. 
 
In future version of AutoQuest there will be facility for uploading question through an image of the questions and questions can be added in batch to the question bank. Therefore, there will be more ease for the user in uploading question to the database. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
REFERENCES: 
 
[1]	Yang Yu, Hongyan Wang, Adaptive Online Exam Questions Based on Systematic Analysis and Design, vol. 4, Wuhan University of Technology, 2008,p. 30. 
[2]	F. logics, “Paper Builder. Foundation for Examination Question Paper generation,” 2009.Available from http://www.freshlogics.com/paper_generator.php  
[3]	Nor Shahida bt Mohd Jamail & Abu Bakar Md Sultan, Shuffling Algorithms for Automatic
Generator Question Paper System,Vol. 3, No.2; May 2010, www.ccsenet.org/cis  
[4]	Guang Cena, Yuxiao Donga, A implementation of an automatic examination paper generation system, Mathematical and ComputerModelling 51 (2010) 1339_1342 
[5]	Memoona Naz, M. Aslam2 and Ehtesham-ul-haq Dar, Utility Based Agent for Test Paper Generation, INTERNATIONAL JOURNAL OFMULTIDISCIPLINARY SCIENCES AND ENGINEERING, VOL. 1, NO.
1, SEPTEMBER 2010 
[6]	Wikipedia (2010a).Randomization.http://en.wikipedia.org/wiki/Randomization 
[7]Wikipedia.(2010c).Shuffling algorithm.http://en.wikipedia.org/wiki/Shuffling_algorithm 
[8] Astech (2010).Atlantic Simulation and Training Technologies.http://www.astech.ie/ 
 


<strong>AutoQuest</strong>

All Rights are reserved. 

Author: Gaurav Keswani.
